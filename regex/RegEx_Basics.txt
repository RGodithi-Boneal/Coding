Regular Expressions Quick Start
   http://www.regular-expressions.info/quickstart.html
	
	 g  -  'Global':  causes the replace call to replace all matches, not just the first one
		
	 \    \  -  Used in javascript to escape string literals (begin and end regex formulas with these)

Single Characters (not line breaks)

   .  -	 matches a single character (wildcard) EXCEPT line break characters
					Most applications have a "dot matches all" or "single line" mode that makes the dot match any single character, including line breaks
					gr.y matches gray, grey, gr%y, etc. Use the dot sparingly. Often, a character class or negated character class is faster and more precise
	 
Shorthand Character Classes


  \d  -  matches one digit character
  \d+ -  matches one or more digit characters
	
  \w  -  matches one "word character" (alphanumeric characters plus underscore)
  \w+ -  matches one or more "word character"s (alphanumeric characters plus underscore)
	
  \s  -  matches one whitespace character (includes tabs and line breaks)
	\s+ -  matches one or more whitespace characters
	
	\b  -  matches a word boundary (where a word character is not followed by another word character)
  \B  -  matches a non-word boundary (previous and next character are the same type)

Non-Printable Characters

  \t  -  matches tab characters (ASCII 0x09)
	[ \t] - match spaces and/or tabs

  \r  -  matches carriage returns (0x0D)
  \n  -  matches line feeds (0x0A)
	NOTE: Remember that Windows text files use \r\n to terminate lines, while UNIX text files use \n
	
	\a  -  matches bell, 0x07 (Exotic Non-Printable Character)
	\e  -  matches escape, 0x1B (Exotic Non-Printable Character)
	\f  -  matches form feed, 0x0C (Exotic Non-Printable Character)
	\v  -  matches vertical tab, 0x0B (Exotic Non-Printable Character)
	
	\uFFFF or \x{FFFF}  -  matches unicode characters (if your application supports unicode)
	\u20AC or \x{20AC}  -  matches the euro currency sign (if your application supports unicode)

	\xFF  -  matches a specific character by its hexadecimal index in the character set (if your application does not support Unicode)
	\xA9  -  matches the copyright symbol in the Latin-1 character set
	
Anchors

	 ^  -  anchor position at the start of the string
	 \A -  anchor position at the start of the string
	 
	 $  -  anchor position at the end of the string
	 \z  -  anchor position at the end of the string
					Anchors DO NOT MATCH any characters, but rather a position
					Most regex engines have a "multi-line" mode that makes ^ match after any line break, and $ before any line break
					Ex: ^b matches only the first b in bob

	\b  -  anchor position at a word boundary
						A word boundary is a position between a character that can be matched by \w and a character that cannot be matched by \w
						\b also matches at the start and/or end of the string if the first and/or last characters in the string are word characters
						\B matches at every position where \b cannot match


Alternation


	cat|dog food  -  matches "cat" OR "dog food"
	(?=cat|dog) food - matches "cat food" OR "dog food"
	
			Alternation has the lowest precedence of all regex operators
			You can add as many alternatives as you want Ex: cat|dog|mouse|fish


Repetition


TOKENS: Regex "tokens" are defined as anything between parenthesis ()

   ?  -  preceding token is optional
						Ex: colou?r matches "colour" or "color"

	 *  -  match the preceding token zero or more times
						Ex: <[A-Za-z][A-Za-z0-9]*>  -  matches an HTML tag without any attributes
					
	 +  -  match the preceding token once or more
						Ex: <[A-Za-z0-9]+>  -  easier to write but matches invalid tags such as <1>
	
	{x}  -  preceding token have "x" or more occurrences
						Ex: \b[1-9][0-9]{3}\b    -  matches a number between 1000 and 9999
						Ex: \b[1-9][0-9]{2,4}\b  -  matches a number between 100 and 99999



Regex Reserved Characters

	These twelve special characters are often called "metacharacters", most of them are errors when used alone:
		\  -  the backslash \
		^  -  the caret ^
		$  -  the dollar sign $
		.  -  the period or dot .   (match any single character)
		|  -  the vertical bar or pipe symbol |
		?  -  the question mark ?,
		*  -  the asterisk or star *   ( match the preceding token zero or more times)
		+  -  the plus sign +  (match the preceding token once or more)
		(  -  the opening parenthesis (
		)  -  the closing parenthesis ) 
		[  -  the opening square bracket [
		{  -  the opening curly brace {

	If you want to use any of these characters as a literal in a regex, you need to escape them with a backslash.
		Ex:   1+1=2   -  matches one or more "1" followed by "1=2"
		Ex:   1\+1=2  -  matches "1+1=2"
	
	The most basic regular expression consists of a single literal character, such as "a"
		It matches the first occurrence of that character in the string
		If the string is "Jack is a boy", it matches the "a" after the "J"

	This regex can match the second "a", too
		It only does so when you tell the regex engine to start searching through the string after the first match
		In a text editor, you can do so by using its "Find Next" or "Search Forward" function
		In a programming language, there is usually a separate function that you can call to continue searching through the string after the previous match.


Character Classes or Character Sets


  [xyz]  -  matches "x", "y", or "z" SINGLE character
	

	A "character class" matches only one out of several characters.
	To match an a or an e, use [ae].
	You could use this in gr[ae]y to match either gray or grey.
	A character class matches only a single character.
	gr[ae]y does not match graay, graey or any such thing.
	The order of the characters inside a character class does not matter.

	You can use a hyphen inside a character class to specify a range of characters.
	[0-9] matches a single digit between 0 and 9.
	You can use more than one range.
	[0-9a-fA-F] matches a single hexadecimal digit, case insensitively.
	You can combine ranges and single characters.
	[0-9a-fxA-FX] matches a hexadecimal digit or the letter X.

	Typing a caret after the opening square bracket negates the character class.
	The result is that the character class matches any character that is not in the character class.
	q[^x] matches qu in question.
	It does not match Iraq since there is no character after the q for the negated character class to match.
	
	
	[xyz]   -  Character Class - Matches any single character in a given set
               |
							 |-->  [a-zA-Z0-9]   is equivalent to   [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWZYZ0123456789]
	
	
	[^xyz]  -  Negated Character Class - Matches any single character NOT a given set
               |
							 |--> [^xyz]   matches anything other than x, y, or z
	

Special global variables
			'Pattern matching' sets some special global variables  (from: https://ruby-doc.org/core-2.1.1/Regexp.html)

    $~  -  is equivalent to ::last_match

    $&  -  'lastMatch' property (static). JS:  "RegExp.lastMatch" or "RegExp['$&']"   contains the complete matched text

    $`  -  contains string before match

    $'  -  contains string after match

    $+  -  contains last capture group
		
		?=  -  (?=regex_here) is a positive lookahead.
						Positive lookahead is used to match (a specific) something followed by (a specific) something else
						"It is a zero-width assertion, meaning that it matches a location that is followed by the regex contained within (?= and )" Reference: http://www.regular-expressions.info/lookaround.html
								Ex: q(?=u)   -   matches a "q" followed by a "u"
		
		?!  -  (?!regex_here) is a negative lookahead. "Negative lookahead is indispensable if you want to match something not followed by something else." 
								Ex: q(?!u)   -   matches a "q" not followed by a "u"
								Ex: /^(?!ignoreme|ignoreme2|ignoremeD)([a-z0-9]+)$/
											hello        <--- matched
											hello123     <--- matched
											ignoreme     <--- skipped
											ignoreme2    <--- skipped
		
		?:  -  (?:regex_here) Non-Capture Subpattern
						|
						|-> ORIGINAL QUESTION: I have a regex that looks like this:    /^(?:\w+\s)*(\w+)$*/    What is the "?:"?
						|
						|-> ORIGINAL ANSWER: That means whatever is matched in (?:\w+\s), even though it's enclosed by () it won't appear in the
										list of matches, only (\w+) will. You're still looking for a specific pattern (in this case, a single whitespace
										character following at least one word), but you don't care what's actually matched.
										 |-> Thanks to StackOverflow user "BoltClock" ( https://stackoverflow.com/questions/3705842/what-does-do-in-regex )
										
    $1
		$2  -  Capture Groups
		$3      |--> Contain any matches found in the (first)(second)(etc) capture group(s)
		...



--> Regex to find all lines starting with "@@" and then having characters until a bunch of spaces
			^(@@[0-9a-zA-Z\_]{1,100})(\ )+(!?\ ){1}		


		
		
The notion that regex doesn't support inverse matching is not entirely true. You can mimic this behavior by using negative look-arounds
		Ex: Find a line NOT containing the substring 'hede':
					^((?!hede).)*$		
		
		
		


--------------------------------------------------------------------------------------------------------------------------------------------
DEBUGGING / QUERY BUILDING




(?!regex_here)
^(?!disabled)

^(DEPLOY_sonarqube|DEPLOY_phpmyadmin|DEPLOY_graylog|UTILITY_mirror_bnet_live_database_over_dev_database)

^DEPLOY_(www|mdev|dev|rdev)\.boneal\.net



